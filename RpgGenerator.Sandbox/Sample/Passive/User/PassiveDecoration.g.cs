// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using RpgGenerator.Basic;
using RpgGenerator.Sandbox.Sample.BattleEvent.User;

namespace RpgGenerator.Sandbox.Sample.Passive.User
{
	internal abstract class PassiveDecoration
	{
		public virtual Task BeforeEventAsync(AttackBattleEvent @event) => Task.CompletedTask;
		public virtual Task AfterEventAsync(AttackBattleEvent @event) => Task.CompletedTask;
		public virtual Task BeforeEventAsync(DamageBattleEvent @event) => Task.CompletedTask;
		public virtual Task AfterEventAsync(DamageBattleEvent @event) => Task.CompletedTask;
		public virtual int ModifyAttack(int source) => source;
		public virtual int ModifyDefence(int source) => source;
	}

	internal sealed class PassiveDecorationHookHandler : IPassiveDecoratorHookHandler
	{
		public Task BeforeEventAsync(IPassiveDecorationProviderBase provider, IBattleEvent @event)
			=> RunAsync(provider, p => SelectBefore(p, @event));
		
		public Task AfterEventAsync(IPassiveDecorationProviderBase provider, IBattleEvent @event)
			=> RunAsync(provider, p => SelectAfter(p, @event));

		private async Task RunAsync(IPassiveDecorationProviderBase provider, Func<PassiveDecoration, Task> selector)
		{
			if (!(provider is IPassiveDecorationProvider concreteProvider)) return;

			foreach (var passiveEffect in concreteProvider.GetPassiveDecorations())
			{
				await selector(passiveEffect);
			}
		}

		private Task SelectBefore(PassiveDecoration passive, IBattleEvent @event) => @event switch
		{
			AttackBattleEvent ev0 => passive.BeforeEventAsync(ev0),
			DamageBattleEvent ev1 => passive.BeforeEventAsync(ev1),
			_ => Task.CompletedTask,
		};

		private Task SelectAfter(PassiveDecoration passive, IBattleEvent @event) => @event switch
		{
			AttackBattleEvent ev0 => passive.AfterEventAsync(ev0),
			DamageBattleEvent ev1 => passive.AfterEventAsync(ev1),
			_ => Task.CompletedTask,
		};
	}

	internal sealed class FinalActorAbility
	{
		private readonly ActorAbility _baseAttribute;
		private readonly IPassiveDecorationProvider _provider;

		public FinalActorAbility(ActorAbility baseAttribute, IPassiveDecorationProvider provider)
		{
			_baseAttribute = baseAttribute;
			_provider = provider;
		}

		public int Attack => Aggregate(_baseAttribute.Attack, p => p.ModifyAttack);
		public int Defence => Aggregate(_baseAttribute.Defence, p => p.ModifyDefence);

		private T Aggregate<T>(T source, Func<PassiveDecoration, Func<T, T>> getModifier)
		{
			return _provider.GetPassiveDecorations()
				.Aggregate(source, (arg1, effect) => getModifier.Invoke(effect).Invoke(arg1));
		}
	}

	internal interface IPassiveDecorationProvider : IPassiveDecorationProviderBase
	{
		IEnumerable<PassiveDecoration> GetPassiveDecorations();
	}
}