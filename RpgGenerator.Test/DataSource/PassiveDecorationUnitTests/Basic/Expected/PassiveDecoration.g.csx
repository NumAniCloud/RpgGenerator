// <autogenerated />
#nullable enable
using System;
using System.Threading.Tasks;
using RpgGenerator.Basic;

namespace RpgGenerator.Test.DataSource.PassiveDecorationUnitTests.Basic.Source
{
	public sealed class PassiveDecoration
	{
		public virtual Task BeforeEventAsync(DamageEvent @event) => Task.CompletedTask;
		public virtual Task AfterEventAsync(DamageEvent @event) => Task.CompletedTask;
		public virtual int ModifyAttack(int source) => source;
		public virtual int ModifyDefence(int source) => source;
	}

	public sealed class PassiveDecorationHookHandler : IPassiveDecoratorHookHandler
	{
		public async Task BeforeEventAsync(IPassiveEventProvider provider, IBattleEvent @event)
		{
			Task SelectFunc(PassiveDecoration passive) => @event switch
			{
				DamageEvent ev0 => passive.BeforeEventAsync(ev0),
				_ => Task.CompletedTask,
			};

			foreach (var passiveEffect in provider.GetPassiveEffects())
			{
				await SelectFunc(passiveEffect);
			}
		}
		
		public async Task AfterEventAsync(IPassiveEventProvider provider, IBattleEvent @event)
		{
			Task SelectFunc(PassiveDecoration passive) => @event switch
			{
				DamageEvent ev0 => passive.AfterEventAsync(ev0),
				_ => Task.CompletedTask,
			};

			foreach (var passiveEffect in provider.GetPassiveEffects())
			{
				await SelectFunc(passiveEffect);
			}
		}
	}

	public sealed class FinalAttributes
	{
		private readonly Attribute _baseAttribute;

		public FinalAttributes(Attribute baseAttribute)
		{
			_baseAttribute = baseAttribute;
		}

		public int Attack => Aggregate(_baseAttribute.Attack, p => p.ModifyAttack);
		public int Defence => Aggregate(_baseAttribute.Defence, p => p.ModifyDefence);
		
		private T Aggregate<T>(T source, Func<PassiveEffect, Func<T, T>> getModifier)
		{
			return _passiveEventProvider.GetPassiveEffects()
				.Aggregate(source, (arg1, effect) => getModifier.Invoke(effect).Invoke(arg1));
		}
	}
}