<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="RpgGenerator.Generator.Utilities"#>
<#@ output extension=".txt" #>
// <autogenerated />
#nullable enable
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using RpgGenerator.Basic;

namespace <#= Root.SourceType.FullNamespace #>
{
<#	var accessibility = Root.SourceType.GetAccessibilityKeyword(); #>
	<#= accessibility #> sealed class <#= Root.Decorator.DecorationName #>
	{
<#	foreach(var hook in Root.Decorator.Hooks) { #>
		public virtual Task BeforeEventAsync(<#= hook.EventTypeName.Name #> @event) => Task.CompletedTask;
		public virtual Task AfterEventAsync(<#= hook.EventTypeName.Name #> @event) => Task.CompletedTask;
<#	} #>
<#	foreach(var modifier in Root.Decorator.Modifiers) { #>
		public virtual <#= modifier.AttributeType #> Modify<#= modifier.AttributeName #>(<#= modifier.AttributeType #> source) => source;
<#	} #>
	}

	<#= accessibility #> sealed class <#= Root.Decorator.DecorationName #>HookHandler : IPassiveDecoratorHookHandler
	{
		public Task BeforeEventAsync(<#= Root.ProviderName #> provider, IBattleEvent @event) => RunAsync(provider, SelectBefore);
		
		public Task AfterEventAsync(<#= Root.ProviderName #> provider, IBattleEvent @event) => RunAsync(provider, SelectAfter);

		private async Task RunAsync(<#= Root.ProviderName #> provider, Func<PassiveDecoration, Task> selector)
		{
			if (!(provider is <#= Root.ProviderName #>)) return;

			foreach (var passiveEffect in provider.GetPassiveDecorations())
			{
				await selector(passiveEffect);
			}
		}

		private Task SelectBefore(<#= Root.Decorator.DecorationName #> passive) => @event switch
		{
<#	var i = 0; #>
<#	foreach(var hook in Root.Decorator.Hooks) { #>
			<#= hook.EventTypeName.Name #> ev<#= i #> => passive.BeforeEventAsync(ev<#= i #>),
<#	i++; #>
<#	} #>
			_ => Task.CompletedTask,
		};

		private Task SelectAfter(<#= Root.Decorator.DecorationName #> passive) => @event switch
		{
<#	var j = 0; #>
<#	foreach(var hook in Root.Decorator.Hooks) { #>
			<#= hook.EventTypeName.Name #> ev<#= j #> => passive.AfterEventAsync(ev<#= j #>),
<#	j++; #>
<#	} #>
			_ => Task.CompletedTask,
		};
	}

<#	foreach(var attribute in Root.FinalAttribute) {  #>
	<#= accessibility #> sealed class Final<#= attribute.AttributeTypeName #>
	{
		private readonly <#= attribute.AttributeTypeName #> _baseAttribute;
		private readonly <#= Root.ProviderName #> _provider;

		public Final<#= attribute.AttributeTypeName #>(<#= attribute.AttributeTypeName #> baseAttribute, <#= Root.ProviderName #> provider)
		{
			_baseAttribute = baseAttribute;
			_provider = provider;
		}

<#		foreach(var member in attribute.Members) { #>
		public <#= member.TypeName #> <#= member.PropertyName #> => Aggregate(_baseAttribute.<#= member.PropertyName #>, p => p.Modify<#= member.PropertyName #>);
<#		} #>

		private T Aggregate<T>(T source, Func<<#= Root.DecorationName #>, Func<T, T>> getModifier)
		{
			return _provider.GetPassiveDecorations()
				.Aggregate(source, (arg1, effect) => getModifier.Invoke(effect).Invoke(arg1));
		}
	}
<#	} #>

	<#= accessibility #> interface <#= Root.ProviderName #>
	{
		IEnumerable<<#= Root.DecorationName #>> GetPassiveDecorations();
	}
}