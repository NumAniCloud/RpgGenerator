<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <autogenerated />
#nullable enable
using System;
using System.Threading.Tasks;
using RpgGenerator.Basic;

namespace <#= Root.DefinitionTypeName.FullNamespace #>
{
<#	foreach(var context in Root.ContextTypes) {  #>
	internal sealed class <#= context.TypeName #>
	{
<#		var delegation = context.ContextDelegationProperties; #>
<#		if(delegation != null) { #>
		private <#= delegation.ContextTypeName #> <#= delegation.GetPropertyName() #> { get; }
<#			foreach(var property in delegation.Properties) { #>
		public <#= property.Type.Name #> <#= property.PropertyName #> => <#= delegation.GetPropertyName() #>.<#= property.PropertyName #>;
<#			} #>
<#		} #>
<#		foreach(var property in context.ContextProperties) { #>
		public <#= property.Type.Name #> <#= property.PropertyName #> { get; }
<#		} #>

		public <#= context.TypeName #>(<#= context.GetCtorParamList() #>)
		{
<#		if(delegation != null) { #>
			<#= delegation.PropertyName #> = <#= delegation.ParameterName #>;
<#		} #>
<#		foreach(var property in context.ContextProperties) { #>
			<#= property.PropertyName #> = <#= property.GetParameterName() #>;
<#		} #>
		}
	}

<#	} #>
	internal sealed class <#= Root.PhaseHandler.TypeName #> : <#= Root.DefinitionTypeName.Name #>
	{
		private readonly <#= Root.PhaseLogic.TypeName #> _logic;

		public <#= Root.PhaseHandler.TypeName #>(<#= Root.PhaseLogic.TypeName #> logic)
		{
			_logic = logic;
		}

<#	foreach(var method in Root.PhaseHandler.PhaseHandlerMethods) { #>
		public async Task<PhaseResult<<#= method.ResultType.TypeName.Name #>>> <#= method.Name #>(<#= method.GetParamList() #>)
		{
			var __phase = new <#= method.GetContextTypeName() #>(<#= method.GetContextArgList() #>);
			return await HandlePhaseFlowAsync(() => _logic.<#= method.LogicMethodName #>(__phase, this));
		}

<#	}  #>
		private async Task<PhaseResult<TResult>> HandlePhaseFlowAsync<TResult>(Func<Task<PhaseResult<TResult>>> logic)
			where TResult : class
		{
			while (true)
			{
				switch (await logic.Invoke())
				{
				case Cancelled<TResult> cancelled: return new Backed<TResult>();
				case Finished<TResult> finished: return finished;
				}
			}
		}

		private sealed class Backed<T> : PhaseResult<T>
		{
			public override T UnWrapOrDefault() => default;
		}
	}

	internal interface <#= Root.PhaseLogic.TypeName #>
	{
<#	foreach(var method in Root.PhaseLogic.PhaseLogicMethods) { #>
		Task<PhaseResult<<#= method.ResultTypeName #>>> <#= method.Name #>(<#= method.ContextTypeName #> phase, <#= Root.DefinitionTypeName.Name #> handler);
<#	} #>
	}
}
